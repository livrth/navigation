### 3.3. 校园导航模块

_此模块代码实现和报告/文档撰写由（2020211592 任晓斌）实现_

#### 3.3.1 需求实现概述

校园导航模块实现了所有课程设计中需求的功能，学生可根据多关键字进行导航，方式如下:

- 学生根据课程名称导航
- 学生根据上课时间导航
- 学生根据上课地点导航

同时学生导航可以有多种导航策略，而且考虑了跨校区等细节情况，方式如下:

- 最短距离策略导航
- 最短时间策略导航（考虑道路的拥挤度）
- 交通工具的最短时间策略（考虑不同的交通工具方式）

- 实现跨校区导航，自动识别是否需要跨校区进行路径规划

具体每个功能的实现细节，以及代码细节分析，文档后续会详细说明。

#### 3.3.2. 核心算法概述

在各种不同策略和要求的最短路实现代码中，均采用 [Floyd 算法](https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm)来预处理出全源最短路，且以文件保存所有预处理好的最短路结果，每次导航只需快速查询即可，不用每次导航都跑一次最短路算法。

为什么采用预预处理全源最短路，而不是每次导航都跑一次 Dijkstra 或者其它单源最短路算法呢？我们先分析一下每次导航都要跑 Dijkstra 算法的时间和空间复杂度。朴素实现的 Dijkstra 算法时间复杂度为 $O(mn)$, 其中 $m$ 为图中的边数，$n$ 为图中的点数。考虑每次导航时如果在线建图一次，其 I/O 所用时间已经是近似 $O(n^2)$ 时间复杂度, 且导航在系统中是较为常用的部分，需要频繁调用。

所以综上考虑，使用 Floyd 算法只需要一次预处理以 $O(n^3)$ 的时间花费即可求出整个地图的全源最短路，因为地图在后续的系统运行中是不会再被修改的，所以我们将预处理出的结果保存下来查询即可。

#### 3.3.3. 需求实现代码细节分析

接下来对导航模块中所有项目需求详细讲述源代码，实现思路，以及执行效果。在地图中，我们约定保留 $1$ 号建筑物为校门, 所有建筑设施的编号均在 $1 \sim 20$ 内, 所有课程导航**只按照在课表中有课的建筑**之间进行路径导航。

导航模块源码目录树:

![image-20220613200850836](nav_model_report.assets/image-20220613200850836.png)

- `guide.cpp` 为导航主要的代码，除了选做算法之外所有的导航功能均在此文件源码实现。
- `*map.txt` 文本文件均为静态生成的地图，使用所有 `gen_map*.cpp` 程序生成各种需求地图。
- `bonus_algo.cpp` 为此项目的选做算法，规划出经过固定点的最短路径。
- `*path.txt` 为提前使用最短路算法处理好的最短路径，输出路径时直接查询即可。

课表文件位于项目 `src/model/identity_model/course_table` 目录下，下面以学生 $2020211591$ 的课表为背景进行导航的所有功能测试和分析。

首先运行程序，以账号 $2020211591$ ，密码 $123$ 登录进入系统:

![image-20220613194459259](nav_model_report.assets/image-20220613194459259.png)

然后在学生菜单中选择选项 $7$ "进行路径导航"，键入回车后即可进行各种导航功能测试。

![image-20220613194534688](nav_model_report.assets/image-20220613194534688.png)

##### 3.3.3.1. 根据课程名称导航

在这个需求中，学生输入需要查询的上课名称，然后系统即可规划同时输出最短路策略。

首先来看程序的演示执行效果，在导航菜单中键入 $1$ 进行根据课程名称导航:

<img src="nav_model_report.assets/image-20220613194645315.png" alt="image-20220613194645315" style="zoom: 33%;" />

回车之后，系统首先会检索当前学生 $2020211591$ 的课表，全部列出该学生本学期的课程，如下:

<img src="nav_model_report.assets/image-20220613195156507.png" alt="image-20220613195156507" style="zoom: 50%;" />

比如我们输入当前正在上的课程《计网》，然后 输入接下来要上的课程《毛概》，键入回车之后，系统首先会自动识别是否需要跨校区上课，然后再输出导航规划的路径，对于这两门课，根据上面说的课表文件可知，是不需要跨校区的，都在沙河校区上课，所以输出结果如下:

![image-20220613195402118](nav_model_report.assets/image-20220613195402118.png)

导航会同时输出所有情况和策略下的最短路规划方案，供学生选择，比如最短步行距离策略，最短步行时间策略，以及通过骑自行车的交通方式，走自行车道的路线和所需时间。

然后再测试一个需要跨校区上课的例子，比如输入当前正在上的课程为《毛概》，接下来要上的课程为《Java》，输出结果如下：

![image-20220613195911718](nav_model_report.assets/image-20220613195911718.png)

此时系统会同时加上跨校区导航，也就是从沙河校区至西土城校区，或者从西土城校区至沙河校区的导航规划，

同时提供定点班车路线: 北邮沙河校区->沙河公交站->马甸桥东公交站->蓟门桥南公交站->北邮海淀校区

以及校车途径路线: 北邮沙河校区->沙河公交站->京藏高速沙河收费站->京藏高速->马甸桥->北邮海淀校区

同样地，选择当在西土城校区上课，然后接下来要上的课输入一门沙河校区的，会以同样的逻辑进行导航，这里就不再赘述。以上就是以课程名称导航的执行效果，接下来分析这部分实现的代码和思路。

- `Guide` 导航类的声明, 源码位于当前模块目录下的 `guide.h`

```cpp
class Guide {
   public:
    int build_now;      //现在所处的建筑位置
    string campus_now;  //现在所处的校区 沙河 西土城
    string stu_id;      //当前操作的学生的学号

    Guide();
    Guide(string in_campus, string stu_id);  //现在所处的校区 当前操作学生的学号
    Guide(string stu_id);                    //当前操作学生的学号

    void build_graph(string campus_now);  //每次导航时候都要先建图 放入内存中

    void guideOperMenu();                 //导航选择菜单
    void print_path_by_course();          //根据课程名称导航
    void print_path_by_location();        //根据上课地点导航 考虑不同校区
    void print_path_by_time();            //根据上课时间导航
    void print_path_by_fixed_building();  //选做算法 经过固定建筑(同校区内的建筑)
};
```

这里声明了所有导航模块中的函数，功能由其后的注释说明，这一部分先讲述根据课程名称导航的函数细节。

- `void Guide::print_path_by_course()` 根据课程名称导航

在函数开始，我们先读入需要的数据，比如学生的课表信息，课表里面包含了每门课的名称，上课地点，建筑的编号等等，我们分别使用哈希表 `std::map` 来映射存储，这样每次查询都可以 $O(logN)$ 复杂度快速查询信息。

```cpp
//课程表信息
//存入课程对应的建筑编号
map<string, int> mp;
map<string, string> campus_map;  //课程 课程所在校区
set<string> all_course;
//星期 第几节 教室 课程名称 所在校区 课程编号 教室所在建筑
string file_date, file_classroom, file_course_name, file_campus;
int file_class_number, name_length;
string file_course_id, garbage;
int file_building_id;
while (ifs >> file_date >> file_class_number >> file_classroom >> file_course_name >> file_campus >> file_course_id >> file_building_id >> name_length) {
    for (int z = 1; z <= name_length; z++) {
        ifs >> garbage;
    }
    mp[file_course_name] = file_building_id;
    campus_map[file_course_name] = file_campus;  //所在校区
    all_course.insert(file_course_name);
}
```

存储信息的核心代码如上，使用哈希表 `map<string, int> mp` 以及 `map<string, string> campus_map` 分别存储课程名称对应的建筑编号，以及课程名称对应的校区之间的映射关系。



##### 3.3.3.2. 根据上课地点导航





##### 3.3.3.3. 根据上课时间导航





##### 3.3.3.4. 经过固定地点导航（选做算法部分）
